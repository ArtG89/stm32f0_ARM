# 15 Режим низкого потребления

Для выполнения этой работы вам потребуется амперметр. Его необходимо подключить вместо перемычки JP2. Таким образом мы будем измерять общее потребление микроконтроллера по шинам Vdd, Vdda, Vbat. Принципиальную схему discovery можно посмотреть в документации к плате.

В этой работе рассмотрим 5 режимов потребления и пример программы, которая осуществляет переход между ними.

## Базовые принципы

Энергопотребление ядра зависит от частоты квадратично, те P ≈ f^2. Потребление периферии не так очевидно и может зависеть от многих параметров. К примеру, если мы питаем светодиод через push-pull вывод, то в зависимости от логического состояния будет различное потребление.

Настраивается EXTI прерывание по кнопке USER.

После каждого нажатия кнопки USER, будем сбрасывать таймер в ноль. Будем считать, что нажатие на кнопку это какое-то внешнее событие, которое нужно обработать и после этого вероятны другие события. Это похоже на то, как вы работаете с компьютером. Пока вы активны, он активен. Если же долго не нажимать на клавиши и не двигать мышкой, то он перейдет в режим сна.

Вспопмним, что P = UI, а U = const, поэтому P ≈ I.

После инициализации микроконтроллер переходит в "боевой" - Run режим на частоте 48МГц, которую мы используем обычно. Измерим потребление в этом режиме. В этом режиме потребляется около 10mА. Если мы питаемся от аккумулятора 3000mAh то, его хватит всего на 3000/10 = 300 часов работы (порядка 12 дней), что мало.

### Работа на низкой частоте

После инициализации стартует таймер. Таймер отсчитывает заданное количество времени, по умолчанию 3с и генерирует прерывание. В обработчике реализован выбор режима с помощью объявления (#define). Нужно задать режим в начале main.c.

```c
// select one of this modes

#define LOW_FREQ
//#define SLEEP
//#define STOP
//#define STANDBY
```

Выберем LOW_FREQ. В этом режиме частота работы уменьшается путем увеличения делителя. Нужно помнить, что в этом режиме не только ухудшается производительность, но и становится некорректной работа зависимой от частоты периферии. Итоговая частота будет 48МГц / 512. Энергопотребление в этом режиме около 2мА, т.е. устройство сможет работать в 5 раз дольше чем в режиме RUN на 48МГц (уже порядка 60 дней).

```c
#ifdef LOW_FREQ
    // set 512 prescaler
    LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_512);
```  

При нажатии на кнопку USER (PA0) генерируется прерывание, в котором мы сконфигурируем RCC. Таким образом микроконтроллер снова работает на 48Мгц и потребляет около 10мА.

```c
void EXTI0_1_IRQHandler()
{
#ifdef LOW_FREQ
    // reinit RCC
    rcc_config();
```

### Sleep

Выберем режим sleep.

```c
#elif defined(SLEEP)
    // enable clock for PWR
    LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
    // select sleep after exiting last interrupt
    LL_LPM_EnableSleepOnExit();
    // enable events and interrups for waking up
    LL_LPM_EnableEventOnPend();
    // enable sleep mode
    LL_LPM_EnableSleep();
    
    // going to sleep // waiting for interrupt mode
    __WFI();
```

Теперь тактирование ядра будет остановлено, но периферия продолжит работу. Потребление в этом режиме будет 5mA для нашей конфигурации (около 30 дней).

### Stop

В этом режиме достигается баланс между потреблением и возможностью МКа быстро возобновить работу.

```c
#elif defined(STOP)
    // enable clock for PWR
    LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
    // enable deep sleep modes
    LL_LPM_EnableDeepSleep();
    // select low power voltage regulator
    LL_PWR_SetPowerMode(LL_PWR_MODE_STOP_LPREGU);
    
    // going to sleep // waiting for interrupt mode
    __WFI();
```

Выход производится нажатием на кнопку USER (PA0). После выхода необходимо переконфигурировать систему тактирования. В зависимости от выбранного регулятора напряжения можно достичь либо более быстрый выход из режима, либо более низкое потребление энергии. В нашем случае потребление получилось 6.37uA, следовательно аккумулятора хватит на 3000/0.00637 ~ 500k часов (порядка 55 лет).

![Stop](stop.jpg)

### StandBy

Это самый экономичный режим. Он похож на stop, но выход возможен c выполнением процедуры init. После выхода из этого режима микроконтроллер оказывается в состоянии аналогичном состоянию после перезагрузки, но с выставленным битом, сигнализирующем нам о том, что микроконтроллер был в режиме сна. В этом режиме потребление выходит 3.84uA (хватит на ~100 лет).

#### PS

Можно оценить потребление энергии с помощью встроенного в CubeMx калькулятора. К примеру, расчеты показывают что в режиме standby потребление будет таким.

![CubeMx](standby.jpg)

В нашем случае оно оказалось близким к расчетному.

Так как модуль SWD (необходимый для загрузки прошивки и отладки) тоже потребляет энергию, даже в режиме standby, то чтобы достичь указанных значений тока, необходимо после прошивки обесточить микроконтроллер и подать питание снова.

##### Задание

_Построить график потребления микроконтроллер в зависимости от рабочей частоты и количества активной периферии._
